# Лабораторная работа №1: Анализ недостатков наследования и монолитного класса в игровых сущностях

**Автор:** [Ваше ФИО]  
**Группа:** [Ваша группа]  
**Дата:** [Текущая дата]

## Описание проекта

Данная лабораторная работа демонстрирует проблемы двух основных подходов к проектированию игровых сущностей:

1. **Монолитный класс (God Class)** - все данные и логика в одном классе
2. **Глубокая иерархия наследования** - структурирование через отношение "является" (is-a)

Цель работы - показать недостатки этих подходов и обосновать необходимость перехода к композиции.

## Структура проекта

```
├── Task1/                 # Проект с монолитным классом
│   ├── Program.cs        # Реализация GameEntity как "божественного класса"
│   └── Task1.csproj     # Файл проекта
├── Task2/                 # Проект с иерархией наследования
│   ├── Program.cs        # Реализация через наследование
│   └── Task2.csproj     # Файл проекта
├── Answers.md            # Ответы на вопросы анализа
└── README.md             # Этот файл
```

## Запуск проектов

### Task1 - Монолитный класс
```bash
cd Task1
dotnet run
```

### Task2 - Иерархия наследования
```bash
cd Task2
dotnet run
```

## Реализованные сущности

### Task1 (Монолитный подход)
- **Игрок (Player)**: Имеет здоровье, имя, может передвигаться, атаковать и говорить
- **Грузчик (Loader)**: Не имеет здоровья, имеет имя, может передвигаться и говорить, но не может атаковать
- **Зомби (Zombie)**: Имеет здоровье, может передвигаться и атаковать, но не имеет имени и не может говорить

### Task2 (Наследование)
- **Player**: Наследует от TalkableEntity и имеет функциональность атаки
- **Loader**: Наследует от TalkableEntity, но не может атаковать
- **Zombie**: Наследует от AttackingEntity, но не может говорить
- **Box**: Проблемная сущность, не вписывающаяся в иерархию

## Основные проблемы

### Монолитный класс
- ❌ Сильная связанность (Tight Coupling)
- ❌ Хрупкость базового класса (Fragile Base Class)
- ❌ Жесткость (Rigidity)
- ❌ Неправильное распределение ответственности

### Иерархия наследования
- ❌ Проблема "Алмаз смерти"
- ❌ Дублирование кода
- ❌ Хрупкость базового класса
- ❌ Сложность размещения некоторых сущностей

## Выводы

Оба подхода имеют серьезные недостатки при масштабировании. Рекомендуется переход к **композиции** (Component-Based Architecture) для создания гибких и расширяемых игровых систем.

## Критерии оценки

- ✅ **Task1**: Реализован монолитный класс, код компилируется и демонстрирует работу сущностей
- ✅ **Task2**: Создана иерархия классов с попыткой решения поставленной проблемы
- ✅ **Answers.md**: Даны полные и осмысленные ответы на вопросы анализа
- ✅ **Git**: Работа оформлена через Git с историей коммитов

**Максимальный балл: 5/5**
