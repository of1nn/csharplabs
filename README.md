# Лабораторная работа №1: Анализ недостатков наследования и монолитного класса в игровых сущностях

**Автор:** Зайцев Дмитрий Андреевич  
**Группа:** Т25ПКвРИ-3m-03

## Описание проекта

Данная лабораторная работа демонстрирует проблемы двух основных подходов к проектированию игровых сущностей:

1. **Монолитный класс (God Class)** - все данные и логика в одном классе
2. **Глубокая иерархия наследования** - структурирование через отношение "является" (is-a)

Цель работы - показать недостатки этих подходов и обосновать необходимость перехода к композиции.

## Структура проекта

```
├── Task1/                 # Проект с монолитным классом
│   ├── Program.cs        # Реализация GameEntity как "божественного класса"
│   └── Task1.csproj     # Файл проекта
├── Task2/                 # Проект с иерархией наследования
│   ├── Program.cs        # Реализация через наследование
│   └── Task2.csproj     # Файл проекта
├── Answers.md            # Ответы на вопросы анализа
└── README.md             # Этот файл
```

## Запуск проектов

### Task1 - Монолитный класс
```bash
cd Task1
dotnet run
```

### Task2 - Иерархия наследования
```bash
cd Task2
dotnet run
```

## Реализованные сущности

### Task1 (Монолитный подход)
- **Игрок (Player)**: Имеет здоровье, имя, может передвигаться, атаковать и говорить
- **Грузчик (Loader)**: Не имеет здоровья, имеет имя, может передвигаться и говорить, но не может атаковать
- **Зомби (Zombie)**: Имеет здоровье, может передвигаться и атаковать, но не имеет имени и не может говорить

### Task2 (Наследование)
- **Player**: Наследует от TalkableEntity и имеет функциональность атаки
- **Loader**: Наследует от TalkableEntity, но не может атаковать
- **Zombie**: Наследует от AttackingEntity, но не может говорить
- **Box**: Проблемная сущность, не вписывающаяся в иерархию
